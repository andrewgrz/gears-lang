
use ast::*;
use std::str::FromStr;

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

SemiColon<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Module = ModStmtAst*;

ModStmtAst: Box<ModStmtAst> = {
    <FunctionDef>,
};

FunctionDef: Box<ModStmtAst> = {
    "def" <name: Name> "(" <args: Args> ")" <exprs: Block> => Box::new(ModStmtAst::FunctionDef{<>})
};


Args = Comma<Arg>;
FnArgs = Comma<Expr>;
Exprs = SemiColon<Expr>;
Stmts = SemiColon<Statement>;

Arg: ArgAst = {
    <name: Name> => ArgAst::new(<>)
};

Block: Vec<Box<StmtAst>> = {
    "{" <stmts: Stmts> "}" => stmts
};

Assignment: Box<StmtAst> = {
    "let" <name: Name> "=" <expr: Expr> => Box::new(StmtAst::Assignment{<>})
}

// These are the AST's that can be at a block level
Statement: Box<StmtAst> = {
    <Assignment>,
    <Expr> => Box::new(StmtAst::Expr(<>)),
}

Expr: ExprAst = {
    <Expr> <ExprOp> <Factor> => ExprAst::new_op(<>),
    <Factor>,
};

FunctionCall: ExprAst = {
    <name: Name> "(" <args: FnArgs> ")" => ExprAst::FunctionCall{<>}
}

IfExpr: ExprAst = {
    "if" <cmp_expr: Expr> <exprs: Block> <else_exprs: ("else" <Block>)?> => ExprAst::new_if(<>)
}

ExprOp: BinOpAst = {
    "+" => BinOpAst::Add,
    "-" => BinOpAst::Sub,
};

Factor: ExprAst = {
    Factor FactorOp Term => ExprAst::new_op(<>),
    Term,
};

FactorOp: BinOpAst = {
    "*" => BinOpAst::Mul,
    "/" => BinOpAst::Div,
};

Term: ExprAst = {
    Name => ExprAst::Variable(<>.to_string()),
    Integer => ExprAst::Integer(<>),
    <IfExpr>,
    "false" => ExprAst::Bool(false),
    "true" => ExprAst::Bool(true),
    <FunctionCall>,     
    "(" <Expr> ")",
};

Name: String = r"[_a-zA-Z][_a-zA-Z0-9]{0,}" => String::from_str(<>).unwrap();

Integer: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap(),
};
